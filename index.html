<!-- Full HTML with real-time adjustable building and impact simulation -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GBU-57 Bomb Impact Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #87CEEB; }
    #ui {
      position: absolute; top: 20px; left: 20px; z-index: 10;
      background: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 6px; color: white;
    }
    button, input, label { display: block; margin: 5px 0; }
    button {
      background-color: #444; color: #fff; border: none;
      padding: 10px 15px; font-size: 14px; border-radius: 5px; cursor: pointer;
    }
    button:hover { background-color: #666; }
    input { width: 60px; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Building Height (feet): <input type="number" id="buildingHeight" value="20"></label>
    <label>Building Width (feet): <input type="number" id="buildingWidth" value="20"></label>
    <label>Building Thickness (feet): <input type="number" id="buildingDepth" value="20"></label>
    <label>Bomb Weight (lbs): <input type="number" id="bombWeight" value="2000"></label>
    <button id="drop">Drop GBU-57</button>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let bomb, falling = false;
    let buildingParts = [], buildingHeight = 20, buildingWidth = 20, buildingDepth = 20;
    let fireball, lightFlash;
    const clock = new THREE.Clock();
    const targetDebris = [];

    init();
    createBuilding();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x87CEEB, 300, 1500);
      scene.background = new THREE.Color(0x87CEEB);
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(100, 150, 300);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      controls = new OrbitControls(camera, renderer.domElement);
      controls.maxDistance = 1000;
      controls.target.set(0, 50, 0);
      controls.update();

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x88bb88, 1);
      hemiLight.position.set(0, 500, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(100, 200, 100);
      scene.add(dirLight);

      const texture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(40, 40);
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(2000, 2000),
        new THREE.MeshStandardMaterial({ map: texture })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      ['buildingHeight','buildingWidth','buildingDepth'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => {
          buildingHeight = parseFloat(document.getElementById('buildingHeight').value);
          buildingWidth = parseFloat(document.getElementById('buildingWidth').value);
          buildingDepth = parseFloat(document.getElementById('buildingDepth').value);
          createBuilding();
        });
      });

      document.getElementById('drop').addEventListener('click', dropBomb);
    }

    function createBuilding() {
      buildingParts.forEach(part => scene.remove(part));
      buildingParts = [];
      const layers = Math.floor(buildingHeight / 2);
      for (let i = 0; i < layers; i++) {
        const geo = new THREE.BoxGeometry(buildingWidth, 2, buildingDepth);
        const mat = new THREE.MeshStandardMaterial({ color: 0x884444 });
        const block = new THREE.Mesh(geo, mat);
        block.position.set(0, 1 + i * 2, 0);
        scene.add(block);
        buildingParts.push(block);
      }
    }

    function dropBomb() {
      if (falling) return;
      const mat = new THREE.MeshStandardMaterial({ color: 0x3333cc });
      const bodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 8, 16);
      const tipGeo = new THREE.ConeGeometry(0.5, 1.5, 16);
      const finGeo = new THREE.BoxGeometry(0.1, 1.5, 0.5);
      const body = new THREE.Mesh(bodyGeo, mat);
      const tip = new THREE.Mesh(tipGeo, mat);
      tip.position.y = 4.75;
      const fins = new THREE.Group();
      for (let j = 0; j < 4; j++) {
        const fin = new THREE.Mesh(finGeo, mat);
        fin.position.set(0, -4, 0.5);
        fin.rotation.y = Math.PI / 2 * j;
        fins.add(fin);
      }
      bomb = new THREE.Group();
      bomb.add(body);
      bomb.add(tip);
      bomb.add(fins);
      bomb.position.set(0, 400, 0);
      scene.add(bomb);
      falling = true;
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (falling && bomb) {
        bomb.position.y -= delta * 100;
        if (bomb.position.y <= 5) {
          createImpact(bomb);
          scene.remove(bomb);
          bomb = null;
          falling = false;
        }
      }
      targetDebris.forEach(piece => {
        piece.position.add(piece.userData.velocity.clone().multiplyScalar(delta));
        piece.rotation.x += piece.userData.rotation.x * delta;
        piece.rotation.y += piece.userData.rotation.y * delta;
      });
      renderer.render(scene, camera);
    }

    function createImpact(bomb) {
      const impactPos = bomb.position.clone();
      const weight = parseFloat(document.getElementById('bombWeight').value);
      const volume = buildingWidth * buildingHeight * buildingDepth;
      const damageRatio = Math.min(weight / (volume / 2), 1);
      const destroyCount = Math.floor(damageRatio * buildingParts.length);

      fireball = new THREE.Mesh(
        new THREE.SphereGeometry(6, 32, 32),
        new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff2200, emissiveIntensity: 1 })
      );
      fireball.position.copy(impactPos);
      scene.add(fireball);

      lightFlash = new THREE.PointLight(0xffaa33, 5, 60);
      lightFlash.position.copy(impactPos);
      scene.add(lightFlash);

      const shockwave = new THREE.Mesh(
        new THREE.RingGeometry(1, 2.5, 32),
        new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
      );
      shockwave.rotation.x = -Math.PI / 2;
      shockwave.position.set(impactPos.x, 0.1, impactPos.z);
      scene.add(shockwave);

      for (let i = 0; i < destroyCount && i < buildingParts.length; i++) {
        const part = buildingParts[i];
        scene.remove(part);
        const debris = new THREE.Mesh(
          new THREE.BoxGeometry(1, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: 0xaa0000 })
        );
        debris.position.copy(part.position);
        debris.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 25,
          Math.random() * 20,
          (Math.random() - 0.5) * 25
        );
        debris.userData.rotation = new THREE.Vector3(
          Math.random() * 2,
          Math.random() * 2,
          Math.random() * 2
        );
        scene.add(debris);
        targetDebris.push(debris);
      }

      buildingParts = buildingParts.slice(destroyCount);

      setTimeout(() => {
        scene.remove(fireball);
        scene.remove(lightFlash);
        scene.remove(shockwave);
      }, 4000);
    }
  </script>
</body>
</html>
